<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[angular]]></title>
    <url>%2F2020%2F02%2F16%2Fangular%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql]]></title>
    <url>%2F2020%2F01%2F21%2Fmysql%2F</url>
    <content type="text"><![CDATA[mysql基础 结构化查询语言(Structured Query Language)简称SQL，mysql是流行的关系型数据 sql基本语法 新建表 SQL语句: CREATE TABLE table_name (column_name column_type);]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础]]></title>
    <url>%2F2019%2F08%2F18%2Fjava%2F</url>
    <content type="text"><![CDATA[java基础该篇文章主要总结一下java的基础语法与基础知识点 参考或出处：- 打翻了牛顿吃饭的碗- 屌丝码农- talenter java中”||”和”|”的区别，以及”&amp;&amp;”与”&amp;”的区别 “||”和”|”的区别 “||”表示逻辑或(也叫做短路或)，当左边为真时就返回true，不对右边继续进行判断 “|”表示按位或,当左边为真时继续判断右边，但是只要有一个为真时就会返回true “&amp;&amp;”与”&amp;”的区别 “&amp;&amp;”表示逻辑与(也叫做短路与)，当左边为假时就返回false，不对右边继续进行判断 “&amp;”表示按位与，当左边为假时会继续判断右边，但是只要有一个为假时就会返回false 取整方法 Math.ceil():表示向上取整； 1Math.ceil(11.3)=12;Math.ceil(-11.3)=-12。 Math.floor():表示向下取整； 12Math.floor(11.6)=12;Math.floor(-11.6)=-12。 Math.round():表示四舍五入； 12Math.round(11.5)=12;Math.round(-11.5)=-11; String s =new String (“syz”);创建了几个String Object? 如果String常理池(常量缓冲区)中，已经创建”xyz”，则不会继续创建，此时只创建了一个对象new String(“xyz”)； 如果String常理池中，没有创建”xyz”，则会创建两个对象，一个对象的值是”xyz”，一个对象new String(“xyz”)。 java23种设计模式 设计模式的概念 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。 设计模式6大原则 开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 里氏代换原则（Liskov Substitution Principle） 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 迪米特法则（最少知道原则）（Demeter Principle） 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。 常用的设计模式 工厂模式（Factory Method） 常用的工厂模式是静态工厂，利用static方法，作为一种类似于常见的工具类Utils等辅助效果，一般情况下工厂类不需要实例化。 1234567891011121314151617181920212223242526272829interface food&#123;&#125;class A implements food&#123;&#125;class B implements food&#123;&#125;class C implements food&#123;&#125;public class StaticFactory &#123; private StaticFactory()&#123;&#125; public static food getA()&#123; return new A(); &#125; public static food getB()&#123; return new B(); &#125; public static food getC()&#123; return new C(); &#125;&#125;class Client&#123; //客户端代码只需要将相应的参数传入即可得到对象 //用户不需要了解工厂类内部的逻辑。 public void get(String name)&#123; food x = null ; if ( name.equals(&quot;A&quot;)) &#123; x = StaticFactory.getA(); &#125;else if ( name.equals(&quot;B&quot;))&#123; x = StaticFactory.getB(); &#125;else &#123; x = StaticFactory.getC(); &#125; &#125;&#125; 抽象工厂模式（Abstract Factory 一个基础接口定义了功能，每个实现接口的子类就是产品，然后定义一个工厂接口，实现了工厂接口的就是工厂，这时候，接口编程的优点就出现了，我们可以新增产品类（只需要实现产品接口），只需要同时新增一个工厂类，客户端就可以轻松调用新产品的代码。 抽象工厂的灵活性就体现在这里，无需改动原有的代码，毕竟对于客户端来说，静态工厂模式在不改动StaticFactory类的代码时无法新增产品，如果采用了抽象工厂模式，就可以轻松的新增拓展类。 实例代码 12345678910111213141516171819202122232425interface food&#123;&#125;class A implements food&#123;&#125;class B implements food&#123;&#125;interface produce&#123; food get();&#125;class FactoryForA implements produce&#123; @Override public food get() &#123; return new A(); &#125;&#125;class FactoryForB implements produce&#123; @Override public food get() &#123; return new B(); &#125;&#125;public class AbstractFactory &#123; public void ClientCode(String name)&#123; food x= new FactoryForA().get(); x = new FactoryForB().get(); &#125;&#125; 单例模式（Singleton） 在内部创建一个实例，构造器全部设置为private，所有方法均在该实例上改动，在创建上要注意类的实例化只能执行一次，可以采用许多种方法来实现，如Synchronized关键字，或者利用内部类等机制来实现。 12345678public class Singleton &#123;private Singleton()&#123;&#125;private static class SingletonBuild&#123; private static Singleton value = new Singleton();&#125;public Singleton getInstance()&#123; return SingletonBuild.value ;&#125; 建造者模式（Builder） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Builder &#123; static class Student&#123; String name = null ; int number = -1 ; String sex = null ; int age = -1 ; String school = null ; //构建器，利用构建器作为参数来构建Student对象 static class StudentBuilder&#123; String name = null ; int number = -1 ; String sex = null ; int age = -1 ; String school = null ; public StudentBuilder setName(String name) &#123; this.name = name; return this ; &#125; public StudentBuilder setNumber(int number) &#123; this.number = number; return this ; &#125; public StudentBuilder setSex(String sex) &#123; this.sex = sex; return this ; &#125; public StudentBuilder setAge(int age) &#123; this.age = age; return this ; &#125; public StudentBuilder setSchool(String school) &#123; this.school = school; return this ; &#125; public Student build() &#123; return new Student(this); &#125; &#125; public Student(StudentBuilder builder)&#123; this.age = builder.age; this.name = builder.name; this.number = builder.number; this.school = builder.school ; this.sex = builder.sex ; &#125; &#125; public static void main( String[] args )&#123; Student a = new Student.StudentBuilder().setAge(13).setName(&quot;LiHua&quot;).build(); Student b = new Student.StudentBuilder().setSchool(&quot;sc&quot;).setSex(&quot;Male&quot;).setName(&quot;ZhangSan&quot;).build(); &#125;&#125; 原型模式（Protype）原型模式就是讲一个对象作为原型，使用clone()方法来创建新的实例。 12345678910111213141516171819202122232425262728public class Prototype implements Cloneable&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override protected Object clone() &#123; try &#123; return super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125;finally &#123; return null; &#125; &#125; public static void main ( String[] args)&#123; Prototype pro = new Prototype(); Prototype pro1 = (Prototype)pro.clone(); &#125;&#125; 此处使用的是浅拷贝，关于深浅拷贝，大家可以另行查找相关资料。 适配器模式（Adapter） 适配器模式的作用就是在原来的类上提供新功能。主要可分为3种： 类适配：创建新类，继承源类，并实现新接口，例如 1class adapter extends oldClass implements newFunc&#123;&#125; 对象适配：创建新类持源类的实例，并实现新接口，例如 1class adapter implements newFunc &#123; private oldClass oldInstance ;&#125; 接口适配：创建新的抽象类实现旧接口方法。例如 1abstract class adapter implements oldClassFunc &#123; void newFunc();&#125; 装饰模式（Decorator) 给一类对象增加新的功能，装饰方法与具体的内部逻辑无关。例如： 12345678910111213interface Source&#123; void method();&#125; public class Decorator implements Source&#123; private Source source ; public void decotate1()&#123; System.out.println(&quot;decorate&quot;); &#125; @Override public void method() &#123; decotate1(); source.method(); &#125;&#125; 代理模式（Proxy）客户端通过代理类访问，代理类实现具体的实现细节，客户只需要使用代理类即可实现操作。 这种模式可以对旧功能进行代理，用一个代理类调用原有的方法，且对产生的结果进行控制。 1234567891011121314151617181920interface Source&#123; void method();&#125;class OldClass implements Source&#123; @Override public void method() &#123; &#125;&#125;class Proxy implements Source&#123; private Source source = new OldClass(); void doSomething()&#123;&#125; @Override public void method() &#123; new Class1().Func1(); source.method(); new Class2().Func2(); doSomething(); &#125;&#125; 外观模式（Facade） 为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加容易使用。这句话是百度百科的解释，有点难懂，但是没事，看下面的例子，我们在启动停止所有子系统的时候，为它们设计一个外观类，这样就可以实现统一的接口，这样即使有新增的子系统subSystem4,也可以在不修改客户端代码的情况下轻松完成。 1234567891011121314151617public class Facade &#123; private subSystem1 subSystem1 = new subSystem1(); private subSystem2 subSystem2 = new subSystem2(); private subSystem3 subSystem3 = new subSystem3(); public void startSystem()&#123; subSystem1.start(); subSystem2.start(); subSystem3.start(); &#125; public void stopSystem()&#123; subSystem1.stop(); subSystem2.stop(); subSystem3.stop(); &#125;&#125; 桥接模式（Bridge）桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。 这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 interface DrawAPI &#123; public void drawCircle(int radius, int x, int y);&#125;class RedCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println(&quot;Drawing Circle[ color: red, radius: &quot; + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;); &#125;&#125;class GreenCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println(&quot;Drawing Circle[ color: green, radius: &quot; + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;); &#125;&#125;abstract class Shape &#123; protected DrawAPI drawAPI; protected Shape(DrawAPI drawAPI)&#123; this.drawAPI = drawAPI; &#125; public abstract void draw();&#125;class Circle extends Shape &#123; private int x, y, radius; public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123; super(drawAPI); this.x = x; this.y = y; this.radius = radius; &#125; public void draw() &#123; drawAPI.drawCircle(radius,x,y); &#125;&#125;//客户端使用代码Shape redCircle = new Circle(100,100, 10, new RedCircle());Shape greenCircle = new Circle(100,100, 10, new GreenCircle());redCircle.draw();greenCircle.draw(); 组合模式（Composite） 组合模式是为了表示那些层次结构，同时部分和整体也可能是一样的结构，常见的如文件夹或者树。举例： 123456789101112131415161718192021abstract class component&#123;&#125;class File extends component&#123; String filename;&#125;class Folder extends component&#123; component[] files ; //既可以放文件File类，也可以放文件夹Folder类。Folder类下又有子文件或子文件夹。 String foldername ; public Folder(component[] source)&#123; files = source ;&#125; public void scan()&#123; for ( component f:files)&#123; if ( f instanceof File)&#123; System.out.println(&quot;File &quot;+((File) f).filename); &#125;else if(f instanceof Folder)&#123; Folder e = (Folder)f ; System.out.println(&quot;Folder &quot;+e.foldername); e.scan(); &#125; &#125; &#125; &#125; 享元模式（Flyweight）使用共享对象的方法，用来尽可能减少内存使用量以及分享资讯。通常使用工厂类辅助，例子中使用一个HashMap类进行辅助判断，数据池中是否已经有了目标实例，如果有，则直接返回，不需要多次创建重复实例。123456789101112131415161718192021222324abstract class flywei&#123; &#125;public class Flyweight extends flywei&#123; Object obj ; public Flyweight(Object obj)&#123; this.obj = obj; &#125;&#125;class FlyweightFactory&#123; private HashMap&lt;Object,Flyweight&gt; data; public FlyweightFactory()&#123; data = new HashMap&lt;&gt;();&#125; public Flyweight getFlyweight(Object object)&#123; if ( data.containsKey(object))&#123; return data.get(object); &#125;else &#123; Flyweight flyweight = new Flyweight(object); data.put(object,flyweight); return flyweight; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unityNotas]]></title>
    <url>%2F2019%2F08%2F15%2FunityNotas%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markDown语法]]></title>
    <url>%2F2019%2F08%2F11%2FHelloWorld%2F</url>
    <content type="text"><![CDATA[MarkDown语法学习参考高鸿祥这是一个goti学习markDown语法的文章 1. 标题123456# 一级菜单## 二级菜单### 三级菜单#### 四级菜单##### 五极菜单###### 六级菜单 效果如下 一级菜单二级菜单三级菜单四级菜单五极菜单六级菜单2.字体1234567**这是加粗的文字***这是倾斜的文字****这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下 这是加粗的文字 这是倾斜的文字 这是斜体加粗的文字 这是加删除线的文字 3.引用感觉这个引用好像并没什么用啊 123&gt;lalalla&gt;&gt;lalalla&gt;&gt;&gt;&gt;lalalla 效果如下 lalalla lalalla lalalla 4.链接以及图片图片 1![这是一个表情包图片](http://108.160.130.156/image/1.jpg &quot;示例图片&quot;) 链接 1[这是一个超链接](https://www.baidu.com) 这是一个超链接 5.列表有序列表1231. 内容2. 内容3. 内容 效果如下 内容 内容 内容 无序列表123- 列表内容+ 列表内容* 列表内容 效果如下 列表内容 列表内容 列表内容 列表嵌套上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 6.表格12345678910|表头|表头|表头||---|:--:|---:||内容|内容|内容||内容|内容|内容|第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右 效果 姓名 技能 名言 cxk 唱跳rap打篮球 你干嘛？ 芦苇 使用高新科技 我芦苇没有开挂！ 杰哥 检查身体 让我康康！ 7.代码123456`单行代码`(```)多行代码(```)使用多行代码的时候去除括号，加括号是为了防止转译 效果如下 单行代码 1多行代码 8.分割线三个或者三个以上的 - 或者 * 都可以。 1234-------******** 效果 9.音乐以及视频先装两个插件 aplayer插件 dplayer插件 12npm install hexo-tag-dplayer --savenpm install hexo-tag-aplayer --save 音乐 网易云 1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=450 src=&quot;//music.163.com/outchain/player?type=0&amp;id=2937381224&amp;auto=0&amp;height=430&quot;&gt;&lt;/iframe&gt; 效果 aplayer插件 单个曲目12345678910title : 曲目标题author: 曲目作者url: 音乐文件 URL 地址picture_url: (可选) 音乐对应的图片地址narrow: （可选）播放器袖珍风格autoplay: (可选) 自动播放，移动端浏览器暂时不支持此功能width:xxx: (可选) 播放器宽度 (默认: 100%)lrc:xxx: （可选）歌词文件 URL 地址&#123;% aplayer &quot;风笛&quot; &quot;DDBY&quot; &quot;http://108.160.130.156/music/DDBY_-_风笛.mp3&quot; &quot;autoplay&quot; %&#125; 效果 var ap = new APlayer({ element: document.getElementById("aplayer-vhqAkbiC"), narrow: false, autoplay: false, showlrc: false, music: { title: "风笛", author: "DDBY", url: "http://108.160.130.156/music/DDBY_-_风笛.mp3", pic: "", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 列表 123456789101112131415161718192021222324252627 &#123;% aplayerlist %&#125;&#123; &quot;narrow&quot;: false, // （可选）播放器袖珍风格 &quot;autoplay&quot;: true, // （可选) 自动播放，移动端浏览器暂时不支持此功能 &quot;mode&quot;: &quot;random&quot;, // （可选）曲目循环类型，有 &apos;random&apos;（随机播放）, &apos;single&apos; (单曲播放), &apos;circulation&apos; (循环播放), &apos;order&apos; (列表播放)， 默认：&apos;circulation&apos; &quot;showlrc&quot;: 3, // （可选）歌词显示配置项，可选项有：1,2,3 &quot;mutex&quot;: true, // （可选）该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 &quot;theme&quot;: &quot;#e6d0b2&quot;, // （可选）播放器风格色彩设置，默认：#b7daff &quot;preload&quot;: &quot;metadata&quot;, // （可选）音乐文件预载入模式，可选项： &apos;none&apos; &apos;metadata&apos; &apos;auto&apos;, 默认: &apos;auto&apos; &quot;listmaxheight&quot;: &quot;513px&quot;, // (可选) 该播放列表的最大长度 &quot;music&quot;: [ &#123; &quot;title&quot;: &quot;CoCo&quot;, &quot;author&quot;: &quot;Jeff Williams&quot;, &quot;url&quot;: &quot;caffeine.mp3&quot;, &quot;pic&quot;: &quot;caffeine.jpeg&quot;, &quot;lrc&quot;: &quot;caffeine.txt&quot; &#125;, &#123; &quot;title&quot;: &quot;アイロニ&quot;, &quot;author&quot;: &quot;鹿乃&quot;, &quot;url&quot;: &quot;irony.mp3&quot;, &quot;pic&quot;: &quot;irony.jpg&quot; &#125; ]&#125;&#123;% endaplayerlist %&#125; 效果 var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","music":[{"title":"风笛","author":"DDBY","url":"http://108.160.130.156/music/DDBY_-_风笛.mp3","pic":""},{"title":"ミシロタウン","author":"景山将太","url":"http://108.160.130.156/music/景山将太_-_ミシロタウン.mp3","pic":""},{"title":"原風景","author":"mamomo","url":"http://108.160.130.156/music/mamomo_-_原風景.mp3","pic":""}]}; options.element = document.getElementById("aplayer-NtRbwhFa"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 视频 原生视频 12&lt;video id=&quot;video&quot; controls=&quot;&quot; preload=&quot;none&quot; poster=&quot;&quot; height=&quot;420&quot; width=&quot;800&quot; &gt; &lt;source id=&quot;mp4&quot; src=&quot;https://goti-bucket.oss-cn-shanghai.aliyuncs.com/movie/kiminama.mp4&quot; type=&quot;video/mp4&quot;&gt; 效果 dplayer插件 1&#123;% dplayer &quot;url=https://goti-bucket.oss-cn-shanghai.aliyuncs.com/movie/kiminama.mp4&quot; &quot;loop=no&quot; &quot;theme=#FADFA3&quot; &quot;autoplay=false&quot; &quot;token=tokendemo&quot; %&#125; 效果 (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","video":{"url":"https://goti-bucket.oss-cn-shanghai.aliyuncs.com/movie/kiminama.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 字体、字号、颜色设置 1234567&lt;font face=&quot;微软雅黑&quot; &gt;微软雅黑字体&lt;/font&gt;&lt;font face=&quot;黑体&quot; &gt;黑体&lt;/font&gt;&lt;font size=3 &gt;3号字&lt;/font&gt;&lt;font size=4 &gt;4号字&lt;/font&gt;&lt;font color=#FF0000 &gt;红色&lt;/font&gt;&lt;font color=#008000 &gt;绿色&lt;/font&gt;&lt;font color=#0000FF &gt;蓝色&lt;/font&gt; 微软雅黑字体黑体3号字4号字红色绿色蓝色]]></content>
      <tags>
        <tag>学习</tag>
        <tag>markDown语法</tag>
      </tags>
  </entry>
</search>
