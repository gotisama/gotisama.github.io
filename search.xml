<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[driving_test]]></title>
    <url>%2F2020%2F02%2F29%2Fdriving-test%2F</url>
    <content type="text"><![CDATA[考驾照科一笔记 1 tips： 难度等级： 《实施条例》第七十八条： 同方向有2条车道的，左侧车道的最低车速为每小时100公里。 2 tips: 八停三减 3 tips: 三条的由120减去10得110，110-20得90，90-30得60，10.20.30逐项递减 4 tips: 车辆的灯光不仅仅是在光线不足的情况下提供照明，而更重要的是起到警示作用，即使在白 天，人们也会首先注意到亮着灯的车辆，不管是行人还是其他车辆的司机。夜间在照明条件 良好的路段行驶，应使用近光灯。 5 tips: 从图中可以看出，是没有中心线的道路。按照规定，机动车在道路上行驶不得超过限速标志、标线标明的速度。在没有限速标志、标线的道路上，没有道路中心线的道路，城市道路为每小时30公里，公路为每小时40公里。 6 tips： 《实施条例》第六十一条： 牵引车和被牵引车均应当开启危险报警闪光灯。 7 tips： 2016年4月1日已经实施的“公安部139号令”已经删除2012年的“公安部123令”中第十三条第二款关于“不能在暂住地初次申领大型货车驾驶证”的规定，取消了异地考驾照对客货车驾驶证的限制，客货车驾驶证也可以在暂住地申领了，但是需要有当地的居住证或者暂住证。 8 tips： 右转让左转 左转让直行 转弯让直行]]></content>
      <tags>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular]]></title>
    <url>%2F2020%2F02%2F16%2Fangular%2F</url>
    <content type="text"><![CDATA[angular简介 参考或转载: leolzi AngularJS 诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVC（Model–view–controller）、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。 #angular基础 新建angular项目 ng new demo 新建文件 ng serve –open 开启项目angular项目目录 node_modules 第三方依赖包存放目录 e2e 端到端的测试目录 用来做自动测试的 src 应用源代码目录 .angular-cli.json Angular命令行工具的配置文件。后期可能会去修改它，引一些其他的第三方的包 比如jquery等 karma.conf.js karma是单元测试的执行器，karma.conf.js是karma的配置文件 package.json 这是一个标准的npm工具的配置文件，这个文件里面列出了该应用程序所使用的第三方依赖包。实际上我们在新建项目的时候，等了半天就是在下载第三方依赖包。下载完成后会放在node_modules这个目录中，后期我们可能会修改这个文件。 protractor.conf.js 也是一个做自动化测试的配置文件 README.md 说明文件 tslint.json 是tslint的配置文件，用来定义TypeScript代码质量检查的规则，不用管它src目录 app目录 包含应用的组件和模块，我们要写的代码都在这个目录 assets目录 资源目录，存储静态资源的 比如图片 environments目录 环境配置。Angular是支持多环境开发的，我们可以在不同的环境下（开发环境，测试环境，生产环境）共用一套代码，主要用来配置环境的 index.html 整个应用的根html，程序启动就是访问这个页面 main.ts 整个项目的入口点，Angular通过这个文件来启动项目 polyfills.ts 主要是用来导入一些必要库，为了让Angular能正常运行在老版本下 styles.css 主要是放一些全局的样式 tsconfig.app.json TypeScript编译器的配置,添加第三方依赖的时候会修改这个文件 tsconfig.spec.json 不用管 test.ts 也是自动化测试用的 typings.d.ts 不用管app(重要)目录app目录是我们要编写的代码目录。我们写的代码都是放在这个目录。一个Angular程序至少需要一个模块和一个组件。在我们新建项目的时候命令行已经默认生成出来了。 新建组件并使用 新建一个组件 加入并使用 写到这发现了一个问题就是webstom的tslint.json里面ts规则，让报错非常离谱，于是我重新找了一个，测试可用，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&#123; &quot;extends&quot;: &quot;tslint:recommended&quot;, &quot;rulesDirectory&quot;: [ &quot;codelyzer&quot; ], &quot;rules&quot;: &#123; &quot;array-type&quot;: false, &quot;arrow-parens&quot;: false, &quot;deprecation&quot;: &#123; &quot;severity&quot;: &quot;warn&quot; &#125;, &quot;import-blacklist&quot;: [ true, &quot;rxjs/Rx&quot; ], &quot;interface-name&quot;: false, &quot;max-classes-per-file&quot;: false, &quot;max-line-length&quot;: [ true, 140 ], &quot;member-access&quot;: false, &quot;member-ordering&quot;: [ false, &#123; &quot;order&quot;: [ &quot;static-field&quot;, &quot;instance-field&quot;, &quot;static-method&quot;, &quot;instance-method&quot; ] &#125; ], &quot;no-consecutive-blank-lines&quot;: false, &quot;no-console&quot;: [ true, &quot;debug&quot;, &quot;info&quot;, &quot;time&quot;, &quot;timeEnd&quot;, &quot;trace&quot; ], &quot;no-empty&quot;: false, &quot;no-inferrable-types&quot;: [ true, &quot;ignore-params&quot;, &quot;ignore-properties&quot; ], &quot;no-non-null-assertion&quot;: true, &quot;no-redundant-jsdoc&quot;: true, &quot;no-switch-case-fall-through&quot;: true, &quot;no-use-before-declare&quot;: true, &quot;no-var-requires&quot;: false, &quot;object-literal-key-quotes&quot;: [ true, &quot;as-needed&quot; ], &quot;object-literal-sort-keys&quot;: false, &quot;ordered-imports&quot;: false, &quot;quotemark&quot;: [ false, &quot;single&quot; ], &quot;trailing-comma&quot;: false, &quot;no-output-on-prefix&quot;: true, &quot;use-input-property-decorator&quot;: true, &quot;use-output-property-decorator&quot;: true, &quot;use-host-property-decorator&quot;: true, &quot;no-input-rename&quot;: true, &quot;no-output-rename&quot;: true, &quot;use-life-cycle-interface&quot;: true, &quot;use-pipe-transform-interface&quot;: true, &quot;component-class-suffix&quot;: true, &quot;directive-class-suffix&quot;: true, &quot;class-name&quot; : false, &quot;variable-name&quot; : false, &quot;one-line&quot; : true, &quot;no-boolean-literal-compare&quot; : false, &quot;no-angle-bracket-type-assertion&quot; : false, &quot;binary-expression-operand-order&quot; : false, &quot;arrow-return-shorthand&quot; : false, &quot;jsdoc-format&quot; : false, &quot;interface-over-type-literal&quot; : false, &quot;no-irregular-whitespace&quot; : false, &quot;number-literal-format&quot; : false, &quot;whitespace&quot; : false, &quot;curly&quot; : false, &quot;typedef-whitespace&quot;:[ false, &#123; &quot;call-signature&quot;: &quot;nospace&quot;, &quot;index-signature&quot;: &quot;nospace&quot;, &quot;parameter&quot;: &quot;nospace&quot;, &quot;property-declaration&quot;: &quot;nospace&quot;, &quot;variable-declaration&quot;: &quot;nospace&quot; &#125;, &#123; &quot;call-signature&quot;: &quot;onespace&quot;, &quot;index-signature&quot;: &quot;onespace&quot;, &quot;parameter&quot;: &quot;onespace&quot;, &quot;property-declaration&quot;: &quot;onespace&quot;, &quot;variable-declaration&quot;: &quot;onespace&quot; &#125; ], &quot;ban-types&quot;: [ false, [ &quot;Object&quot;, &quot;Use &#123;&#125; instead.&quot; ], [&quot;String&quot;] ], &quot;prefer-const&quot;: false, &quot;no-trailing-whitespace&quot;: false, &quot;comment-format&quot;: false &#125;&#125; html里引用ts属性 ts里书写的属性 发现一个问题，我看教程里面对象是要加:object对他进行规范的，而我规范了就会报错，最后去掉:object才成功在html引用到属性 html里的引用 网页样式 html标签使用angular属性 绑定内容 &lt;div [title]=&quot;studentTitle&quot;&gt;学生标题&lt;/div&gt; 效果如下： angular的html解析标签 1234///未解析&lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;///解析&lt;div [innerHTML]=&apos;content&apos;&gt;&lt;/div&gt; 效果如下: angular的html里可以进行简单的运算 &lt;div&gt;1+3=4&lt;/div&gt; 效果如图： angular里的数组以及循环 1234567&lt;div&gt; &lt;ul&gt; &lt;li *ngFor=&quot;let item of arr&quot;&gt; &#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 效果如下：]]></content>
      <tags>
        <tag>web前端</tag>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql]]></title>
    <url>%2F2020%2F01%2F21%2Fmysql%2F</url>
    <content type="text"><![CDATA[mysql基础 结构化查询语言(Structured Query Language)简称SQL，mysql是流行的关系型数据库 sql基本语法 新建表 SQL语句: CREATE TABLE table_name (column_name column_type);]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础]]></title>
    <url>%2F2019%2F08%2F18%2Fjava%2F</url>
    <content type="text"><![CDATA[java基础该篇文章主要总结一下java的基础语法与基础知识点 参考或出处：- 打翻了牛顿吃饭的碗- 屌丝码农- talenter java中”||”和”|”的区别，以及”&amp;&amp;”与”&amp;”的区别 “||”和”|”的区别 “||”表示逻辑或(也叫做短路或)，当左边为真时就返回true，不对右边继续进行判断 “|”表示按位或,当左边为真时继续判断右边，但是只要有一个为真时就会返回true “&amp;&amp;”与”&amp;”的区别 “&amp;&amp;”表示逻辑与(也叫做短路与)，当左边为假时就返回false，不对右边继续进行判断 “&amp;”表示按位与，当左边为假时会继续判断右边，但是只要有一个为假时就会返回false 取整方法 Math.ceil():表示向上取整； 1Math.ceil(11.3)=12;Math.ceil(-11.3)=-12。 Math.floor():表示向下取整； 12Math.floor(11.6)=12;Math.floor(-11.6)=-12。 Math.round():表示四舍五入； 12Math.round(11.5)=12;Math.round(-11.5)=-11; String s =new String (“syz”);创建了几个String Object? 如果String常理池(常量缓冲区)中，已经创建”xyz”，则不会继续创建，此时只创建了一个对象new String(“xyz”)； 如果String常理池中，没有创建”xyz”，则会创建两个对象，一个对象的值是”xyz”，一个对象new String(“xyz”)。 java23种设计模式 设计模式的概念 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。 设计模式6大原则 开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 里氏代换原则（Liskov Substitution Principle） 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 迪米特法则（最少知道原则）（Demeter Principle） 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。 常用的设计模式 工厂模式（Factory Method） 常用的工厂模式是静态工厂，利用static方法，作为一种类似于常见的工具类Utils等辅助效果，一般情况下工厂类不需要实例化。 1234567891011121314151617181920212223242526272829interface food&#123;&#125;class A implements food&#123;&#125;class B implements food&#123;&#125;class C implements food&#123;&#125;public class StaticFactory &#123; private StaticFactory()&#123;&#125; public static food getA()&#123; return new A(); &#125; public static food getB()&#123; return new B(); &#125; public static food getC()&#123; return new C(); &#125;&#125;class Client&#123; //客户端代码只需要将相应的参数传入即可得到对象 //用户不需要了解工厂类内部的逻辑。 public void get(String name)&#123; food x = null ; if ( name.equals(&quot;A&quot;)) &#123; x = StaticFactory.getA(); &#125;else if ( name.equals(&quot;B&quot;))&#123; x = StaticFactory.getB(); &#125;else &#123; x = StaticFactory.getC(); &#125; &#125;&#125; 抽象工厂模式（Abstract Factory 一个基础接口定义了功能，每个实现接口的子类就是产品，然后定义一个工厂接口，实现了工厂接口的就是工厂，这时候，接口编程的优点就出现了，我们可以新增产品类（只需要实现产品接口），只需要同时新增一个工厂类，客户端就可以轻松调用新产品的代码。 抽象工厂的灵活性就体现在这里，无需改动原有的代码，毕竟对于客户端来说，静态工厂模式在不改动StaticFactory类的代码时无法新增产品，如果采用了抽象工厂模式，就可以轻松的新增拓展类。 实例代码 12345678910111213141516171819202122232425interface food&#123;&#125;class A implements food&#123;&#125;class B implements food&#123;&#125;interface produce&#123; food get();&#125;class FactoryForA implements produce&#123; @Override public food get() &#123; return new A(); &#125;&#125;class FactoryForB implements produce&#123; @Override public food get() &#123; return new B(); &#125;&#125;public class AbstractFactory &#123; public void ClientCode(String name)&#123; food x= new FactoryForA().get(); x = new FactoryForB().get(); &#125;&#125; 单例模式（Singleton） 在内部创建一个实例，构造器全部设置为private，所有方法均在该实例上改动，在创建上要注意类的实例化只能执行一次，可以采用许多种方法来实现，如Synchronized关键字，或者利用内部类等机制来实现。 12345678public class Singleton &#123;private Singleton()&#123;&#125;private static class SingletonBuild&#123; private static Singleton value = new Singleton();&#125;public Singleton getInstance()&#123; return SingletonBuild.value ;&#125; 建造者模式（Builder） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Builder &#123; static class Student&#123; String name = null ; int number = -1 ; String sex = null ; int age = -1 ; String school = null ; //构建器，利用构建器作为参数来构建Student对象 static class StudentBuilder&#123; String name = null ; int number = -1 ; String sex = null ; int age = -1 ; String school = null ; public StudentBuilder setName(String name) &#123; this.name = name; return this ; &#125; public StudentBuilder setNumber(int number) &#123; this.number = number; return this ; &#125; public StudentBuilder setSex(String sex) &#123; this.sex = sex; return this ; &#125; public StudentBuilder setAge(int age) &#123; this.age = age; return this ; &#125; public StudentBuilder setSchool(String school) &#123; this.school = school; return this ; &#125; public Student build() &#123; return new Student(this); &#125; &#125; public Student(StudentBuilder builder)&#123; this.age = builder.age; this.name = builder.name; this.number = builder.number; this.school = builder.school ; this.sex = builder.sex ; &#125; &#125; public static void main( String[] args )&#123; Student a = new Student.StudentBuilder().setAge(13).setName(&quot;LiHua&quot;).build(); Student b = new Student.StudentBuilder().setSchool(&quot;sc&quot;).setSex(&quot;Male&quot;).setName(&quot;ZhangSan&quot;).build(); &#125;&#125; 原型模式（Protype）原型模式就是讲一个对象作为原型，使用clone()方法来创建新的实例。 12345678910111213141516171819202122232425262728public class Prototype implements Cloneable&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override protected Object clone() &#123; try &#123; return super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125;finally &#123; return null; &#125; &#125; public static void main ( String[] args)&#123; Prototype pro = new Prototype(); Prototype pro1 = (Prototype)pro.clone(); &#125;&#125; 此处使用的是浅拷贝，关于深浅拷贝，大家可以另行查找相关资料。 适配器模式（Adapter） 适配器模式的作用就是在原来的类上提供新功能。主要可分为3种： 类适配：创建新类，继承源类，并实现新接口，例如 1class adapter extends oldClass implements newFunc&#123;&#125; 对象适配：创建新类持源类的实例，并实现新接口，例如 1class adapter implements newFunc &#123; private oldClass oldInstance ;&#125; 接口适配：创建新的抽象类实现旧接口方法。例如 1abstract class adapter implements oldClassFunc &#123; void newFunc();&#125; 装饰模式（Decorator) 给一类对象增加新的功能，装饰方法与具体的内部逻辑无关。例如： 12345678910111213interface Source&#123; void method();&#125; public class Decorator implements Source&#123; private Source source ; public void decotate1()&#123; System.out.println(&quot;decorate&quot;); &#125; @Override public void method() &#123; decotate1(); source.method(); &#125;&#125; 代理模式（Proxy）客户端通过代理类访问，代理类实现具体的实现细节，客户只需要使用代理类即可实现操作。 这种模式可以对旧功能进行代理，用一个代理类调用原有的方法，且对产生的结果进行控制。 1234567891011121314151617181920interface Source&#123; void method();&#125;class OldClass implements Source&#123; @Override public void method() &#123; &#125;&#125;class Proxy implements Source&#123; private Source source = new OldClass(); void doSomething()&#123;&#125; @Override public void method() &#123; new Class1().Func1(); source.method(); new Class2().Func2(); doSomething(); &#125;&#125; 外观模式（Facade） 为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加容易使用。这句话是百度百科的解释，有点难懂，但是没事，看下面的例子，我们在启动停止所有子系统的时候，为它们设计一个外观类，这样就可以实现统一的接口，这样即使有新增的子系统subSystem4,也可以在不修改客户端代码的情况下轻松完成。 1234567891011121314151617public class Facade &#123; private subSystem1 subSystem1 = new subSystem1(); private subSystem2 subSystem2 = new subSystem2(); private subSystem3 subSystem3 = new subSystem3(); public void startSystem()&#123; subSystem1.start(); subSystem2.start(); subSystem3.start(); &#125; public void stopSystem()&#123; subSystem1.stop(); subSystem2.stop(); subSystem3.stop(); &#125;&#125; 桥接模式（Bridge）桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。 这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 interface DrawAPI &#123; public void drawCircle(int radius, int x, int y);&#125;class RedCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println(&quot;Drawing Circle[ color: red, radius: &quot; + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;); &#125;&#125;class GreenCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println(&quot;Drawing Circle[ color: green, radius: &quot; + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;); &#125;&#125;abstract class Shape &#123; protected DrawAPI drawAPI; protected Shape(DrawAPI drawAPI)&#123; this.drawAPI = drawAPI; &#125; public abstract void draw();&#125;class Circle extends Shape &#123; private int x, y, radius; public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123; super(drawAPI); this.x = x; this.y = y; this.radius = radius; &#125; public void draw() &#123; drawAPI.drawCircle(radius,x,y); &#125;&#125;//客户端使用代码Shape redCircle = new Circle(100,100, 10, new RedCircle());Shape greenCircle = new Circle(100,100, 10, new GreenCircle());redCircle.draw();greenCircle.draw(); 组合模式（Composite） 组合模式是为了表示那些层次结构，同时部分和整体也可能是一样的结构，常见的如文件夹或者树。举例： 123456789101112131415161718192021abstract class component&#123;&#125;class File extends component&#123; String filename;&#125;class Folder extends component&#123; component[] files ; //既可以放文件File类，也可以放文件夹Folder类。Folder类下又有子文件或子文件夹。 String foldername ; public Folder(component[] source)&#123; files = source ;&#125; public void scan()&#123; for ( component f:files)&#123; if ( f instanceof File)&#123; System.out.println(&quot;File &quot;+((File) f).filename); &#125;else if(f instanceof Folder)&#123; Folder e = (Folder)f ; System.out.println(&quot;Folder &quot;+e.foldername); e.scan(); &#125; &#125; &#125; &#125; 享元模式（Flyweight）使用共享对象的方法，用来尽可能减少内存使用量以及分享资讯。通常使用工厂类辅助，例子中使用一个HashMap类进行辅助判断，数据池中是否已经有了目标实例，如果有，则直接返回，不需要多次创建重复实例。123456789101112131415161718192021222324abstract class flywei&#123; &#125;public class Flyweight extends flywei&#123; Object obj ; public Flyweight(Object obj)&#123; this.obj = obj; &#125;&#125;class FlyweightFactory&#123; private HashMap&lt;Object,Flyweight&gt; data; public FlyweightFactory()&#123; data = new HashMap&lt;&gt;();&#125; public Flyweight getFlyweight(Object object)&#123; if ( data.containsKey(object))&#123; return data.get(object); &#125;else &#123; Flyweight flyweight = new Flyweight(object); data.put(object,flyweight); return flyweight; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unityNotas]]></title>
    <url>%2F2019%2F08%2F15%2FunityNotas%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>unity</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markDown语法]]></title>
    <url>%2F2019%2F08%2F11%2FHelloWorld%2F</url>
    <content type="text"><![CDATA[MarkDown语法学习参考高鸿祥这是一个goti学习markDown语法的文章 1. 标题123456# 一级菜单## 二级菜单### 三级菜单#### 四级菜单##### 五极菜单###### 六级菜单 效果如下 一级菜单二级菜单三级菜单四级菜单五极菜单六级菜单2.字体1234567**这是加粗的文字***这是倾斜的文字****这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下 这是加粗的文字 这是倾斜的文字 这是斜体加粗的文字 这是加删除线的文字 3.引用感觉这个引用好像并没什么用啊 123&gt;lalalla&gt;&gt;lalalla&gt;&gt;&gt;&gt;lalalla 效果如下 lalalla lalalla lalalla 4.链接以及图片图片 1![这是一个表情包图片](http://108.160.130.156/image/1.jpg &quot;示例图片&quot;) 链接 1[这是一个超链接](https://www.baidu.com) 这是一个超链接 5.列表有序列表1231. 内容2. 内容3. 内容 效果如下 内容 内容 内容 无序列表123- 列表内容+ 列表内容* 列表内容 效果如下 列表内容 列表内容 列表内容 列表嵌套上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 6.表格12345678910|表头|表头|表头||---|:--:|---:||内容|内容|内容||内容|内容|内容|第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右 效果 姓名 技能 名言 cxk 唱跳rap打篮球 你干嘛？ 芦苇 使用高新科技 我芦苇没有开挂！ 杰哥 检查身体 让我康康！ 7.代码123456`单行代码`(```)多行代码(```)使用多行代码的时候去除括号，加括号是为了防止转译 效果如下 单行代码 1多行代码 8.分割线三个或者三个以上的 - 或者 * 都可以。 1234-------******** 效果 9.音乐以及视频先装两个插件 aplayer插件 dplayer插件 12npm install hexo-tag-dplayer --savenpm install hexo-tag-aplayer --save 音乐 网易云 1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=450 src=&quot;//music.163.com/outchain/player?type=0&amp;id=2937381224&amp;auto=0&amp;height=430&quot;&gt;&lt;/iframe&gt; 效果 aplayer插件 单个曲目12345678910title : 曲目标题author: 曲目作者url: 音乐文件 URL 地址picture_url: (可选) 音乐对应的图片地址narrow: （可选）播放器袖珍风格autoplay: (可选) 自动播放，移动端浏览器暂时不支持此功能width:xxx: (可选) 播放器宽度 (默认: 100%)lrc:xxx: （可选）歌词文件 URL 地址&#123;% aplayer &quot;风笛&quot; &quot;DDBY&quot; &quot;http://108.160.130.156/music/DDBY_-_风笛.mp3&quot; &quot;autoplay&quot; %&#125; 效果 var ap = new APlayer({ element: document.getElementById("aplayer-eDkhPoBd"), narrow: false, autoplay: false, showlrc: false, music: { title: "风笛", author: "DDBY", url: "http://108.160.130.156/music/DDBY_-_风笛.mp3", pic: "", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 列表 123456789101112131415161718192021222324252627 &#123;% aplayerlist %&#125;&#123; &quot;narrow&quot;: false, // （可选）播放器袖珍风格 &quot;autoplay&quot;: true, // （可选) 自动播放，移动端浏览器暂时不支持此功能 &quot;mode&quot;: &quot;random&quot;, // （可选）曲目循环类型，有 &apos;random&apos;（随机播放）, &apos;single&apos; (单曲播放), &apos;circulation&apos; (循环播放), &apos;order&apos; (列表播放)， 默认：&apos;circulation&apos; &quot;showlrc&quot;: 3, // （可选）歌词显示配置项，可选项有：1,2,3 &quot;mutex&quot;: true, // （可选）该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 &quot;theme&quot;: &quot;#e6d0b2&quot;, // （可选）播放器风格色彩设置，默认：#b7daff &quot;preload&quot;: &quot;metadata&quot;, // （可选）音乐文件预载入模式，可选项： &apos;none&apos; &apos;metadata&apos; &apos;auto&apos;, 默认: &apos;auto&apos; &quot;listmaxheight&quot;: &quot;513px&quot;, // (可选) 该播放列表的最大长度 &quot;music&quot;: [ &#123; &quot;title&quot;: &quot;CoCo&quot;, &quot;author&quot;: &quot;Jeff Williams&quot;, &quot;url&quot;: &quot;caffeine.mp3&quot;, &quot;pic&quot;: &quot;caffeine.jpeg&quot;, &quot;lrc&quot;: &quot;caffeine.txt&quot; &#125;, &#123; &quot;title&quot;: &quot;アイロニ&quot;, &quot;author&quot;: &quot;鹿乃&quot;, &quot;url&quot;: &quot;irony.mp3&quot;, &quot;pic&quot;: &quot;irony.jpg&quot; &#125; ]&#125;&#123;% endaplayerlist %&#125; 效果 var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","music":[{"title":"风笛","author":"DDBY","url":"http://108.160.130.156/music/DDBY_-_风笛.mp3","pic":""},{"title":"ミシロタウン","author":"景山将太","url":"http://108.160.130.156/music/景山将太_-_ミシロタウン.mp3","pic":""},{"title":"原風景","author":"mamomo","url":"http://108.160.130.156/music/mamomo_-_原風景.mp3","pic":""}]}; options.element = document.getElementById("aplayer-HplvpspF"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 视频 原生视频 12&lt;video id=&quot;video&quot; controls=&quot;&quot; preload=&quot;none&quot; poster=&quot;&quot; height=&quot;420&quot; width=&quot;800&quot; &gt; &lt;source id=&quot;mp4&quot; src=&quot;https://goti-bucket.oss-cn-shanghai.aliyuncs.com/movie/kiminama.mp4&quot; type=&quot;video/mp4&quot;&gt; 效果 dplayer插件 1&#123;% dplayer &quot;url=https://goti-bucket.oss-cn-shanghai.aliyuncs.com/movie/kiminama.mp4&quot; &quot;loop=no&quot; &quot;theme=#FADFA3&quot; &quot;autoplay=false&quot; &quot;token=tokendemo&quot; %&#125; 效果 (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","video":{"url":"https://goti-bucket.oss-cn-shanghai.aliyuncs.com/movie/kiminama.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 字体、字号、颜色设置 1234567&lt;font face=&quot;微软雅黑&quot; &gt;微软雅黑字体&lt;/font&gt;&lt;font face=&quot;黑体&quot; &gt;黑体&lt;/font&gt;&lt;font size=3 &gt;3号字&lt;/font&gt;&lt;font size=4 &gt;4号字&lt;/font&gt;&lt;font color=#FF0000 &gt;红色&lt;/font&gt;&lt;font color=#008000 &gt;绿色&lt;/font&gt;&lt;font color=#0000FF &gt;蓝色&lt;/font&gt; 微软雅黑字体黑体3号字4号字红色绿色蓝色]]></content>
      <tags>
        <tag>学习</tag>
        <tag>markDown语法</tag>
      </tags>
  </entry>
</search>
